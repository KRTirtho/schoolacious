-- This script was generated by the Schema Diff utility in pgAdmin 4
-- For the circular dependencies, the order in which Schema Diff writes the objects is not very sophisticated
-- and may require manual changes to the script to ensure changes are applied in the correct order.
-- Please report an issue for any failure with the reproduction steps.
CREATE TABLE IF NOT EXISTS public.school (
  id uuid NOT NULL DEFAULT uuid_generate_v4(),
  created_at timestamp with time zone NOT NULL DEFAULT (now() AT TIME ZONE 'utc'::text),
  updated_at timestamp with time zone NOT NULL DEFAULT (now() AT TIME ZONE 'utc'::text),
  name text COLLATE pg_catalog."default" NOT NULL,
  short_name character varying(20) COLLATE pg_catalog."default" NOT NULL,
  email character varying(100) COLLATE pg_catalog."default" NOT NULL,
  phone character varying(15) COLLATE pg_catalog."default" NOT NULL,
  description text COLLATE pg_catalog."default",
  owner_id uuid,
  CONSTRAINT school_pkey PRIMARY KEY (id),
  CONSTRAINT school_email_key UNIQUE (email),
  CONSTRAINT school_phone_key UNIQUE (phone),
  CONSTRAINT school_short_name_key UNIQUE (short_name),
  CONSTRAINT school_owner_id_fkey FOREIGN KEY (owner_id) REFERENCES auth.users (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION
) TABLESPACE pg_default;
ALTER TABLE IF EXISTS public.school OWNER to supabase_admin;
ALTER TABLE IF EXISTS public.school ENABLE ROW LEVEL SECURITY;
GRANT ALL ON TABLE public.school TO anon;
GRANT ALL ON TABLE public.school TO authenticated;
GRANT ALL ON TABLE public.school TO postgres;
GRANT ALL ON TABLE public.school TO service_role;
GRANT ALL ON TABLE public.school TO supabase_admin;
COMMENT ON TABLE public.school IS 'Stores important metadata for each new institution';
CREATE POLICY "allow all authenticated user to see school details" ON public.school AS PERMISSIVE FOR
SELECT TO public USING ((auth.role() = 'authenticated'::text));
CREATE TABLE IF NOT EXISTS public.grade (
  id uuid NOT NULL DEFAULT uuid_generate_v4(),
  standard integer NOT NULL,
  created_at timestamp with time zone NOT NULL DEFAULT timezone('utc'::text, now()),
  updated_at timestamp with time zone NOT NULL DEFAULT timezone('utc'::text, now()),
  owner_id uuid,
  CONSTRAINT "PK_grade_id" PRIMARY KEY (id),
  CONSTRAINT "UQ_grade_standard_owner" UNIQUE (standard, owner_id),
  CONSTRAINT "FK_grade_owner" FOREIGN KEY (owner_id) REFERENCES public.school (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION
) TABLESPACE pg_default;
ALTER TABLE IF EXISTS public.grade OWNER to supabase_admin;
GRANT ALL ON TABLE public.grade TO anon;
GRANT ALL ON TABLE public.grade TO authenticated;
GRANT ALL ON TABLE public.grade TO postgres;
GRANT ALL ON TABLE public.grade TO service_role;
GRANT ALL ON TABLE public.grade TO supabase_admin;
CREATE TABLE IF NOT EXISTS public.roles (
  id uuid NOT NULL DEFAULT uuid_generate_v4(),
  created_at timestamp with time zone NOT NULL DEFAULT (now() AT TIME ZONE 'utc'::text),
  updated_at timestamp with time zone NOT NULL DEFAULT (now() AT TIME ZONE 'utc'::text),
  owner_id uuid NOT NULL,
  name character varying(50) COLLATE pg_catalog."default" NOT NULL,
  description text COLLATE pg_catalog."default",
  permissions character varying(20) [] COLLATE pg_catalog."default" NOT NULL,
  scoped_grade_id uuid,
  scoped_section_id uuid,
  scoped_class_id uuid,
  CONSTRAINT cpk_roles PRIMARY KEY (id),
  CONSTRAINT cuq_roles UNIQUE (owner_id, name),
  CONSTRAINT cuq_roles_scoped_grade UNIQUE (owner_id, name, scoped_grade_id),
  CONSTRAINT cuq_roles_scoped_grade_section UNIQUE (
    owner_id,
    name,
    scoped_grade_id,
    scoped_section_id
  ),
  CONSTRAINT cuq_roles_scoped_grade_section_class UNIQUE (
    owner_id,
    name,
    scoped_grade_id,
    scoped_section_id,
    scoped_class_id
  ),
  CONSTRAINT roles_owner_id_fkey FOREIGN KEY (owner_id) REFERENCES public.school (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
  CONSTRAINT roles_scoped_grade_id_fkey FOREIGN KEY (scoped_grade_id) REFERENCES public.grade (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
  CONSTRAINT cck_roles_permissions CHECK (
    permissions && '{school:modify,grade:create,grade:modify,grade:delete,section:create,section:modify,section:delete,class:create,class:modify,class:delete}'::character varying []
  )
) TABLESPACE pg_default;
ALTER TABLE IF EXISTS public.roles OWNER to supabase_admin;
ALTER TABLE IF EXISTS public.roles ENABLE ROW LEVEL SECURITY;
GRANT ALL ON TABLE public.roles TO anon;
GRANT ALL ON TABLE public.roles TO authenticated;
GRANT ALL ON TABLE public.roles TO postgres;
GRANT ALL ON TABLE public.roles TO service_role;
GRANT ALL ON TABLE public.roles TO supabase_admin;
COMMENT ON TABLE public.roles IS 'Contains the custom roles with various 
"allowed" permissions created by the owner';
ALTER TABLE auth.users
ADD COLUMN role_id uuid NOT NULL,
  ADD CONSTRAINT "fk_user_role" FOREIGN KEY (role_id) REFERENCES roles(id);
CREATE POLICY "allow authenticated user with no school association to insert" ON public.school AS PERMISSIVE FOR
INSERT TO public WITH CHECK (
    (
      EXISTS (
        SELECT 1
        FROM auth.users
        WHERE (
            (users.id = auth.uid())
            AND (auth.role() = 'authenticated'::text)
            AND (users.role_id IS NULL)
          )
      )
    )
  );
CREATE POLICY "allow users with school:modify permission to update" ON public.school AS PERMISSIVE FOR
UPDATE TO public USING (
    (
      EXISTS (
        SELECT 1
        FROM (
            auth.users
            JOIN roles ON ((users.role_id = roles.id))
          )
        WHERE (
            (users.id = auth.uid())
            AND (
              roles.permissions @> '{school:modify}'::character varying []
            )
          )
      )
    )
  ) WITH CHECK (
    (
      EXISTS (
        SELECT 1
        FROM (
            auth.users
            JOIN roles ON ((users.role_id = roles.id))
          )
        WHERE (
            (users.id = auth.uid())
            AND (
              roles.permissions @> '{school:modify}'::character varying []
            )
          )
      )
    )
  );
CREATE TABLE IF NOT EXISTS public.invitation (
  id uuid NOT NULL DEFAULT uuid_generate_v4(),
  created_at timestamp with time zone NOT NULL DEFAULT (now() AT TIME ZONE 'utc'::text),
  updated_at timestamp with time zone NOT NULL DEFAULT (now() AT TIME ZONE 'utc'::text),
  role_id uuid,
  owner_id uuid,
  receiver_id uuid,
  CONSTRAINT cpk_invitation PRIMARY KEY (id),
  CONSTRAINT cuq_invitation UNIQUE (owner_id, receiver_id),
  CONSTRAINT fk_invitation_owner FOREIGN KEY (owner_id) REFERENCES auth.users (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
  CONSTRAINT fk_invitation_receiver FOREIGN KEY (receiver_id) REFERENCES public.school (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
  CONSTRAINT fk_invitation_role FOREIGN KEY (role_id) REFERENCES public.roles (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION
) TABLESPACE pg_default;
ALTER TABLE IF EXISTS public.invitation OWNER to supabase_admin;
ALTER TABLE IF EXISTS public.invitation ENABLE ROW LEVEL SECURITY;
GRANT ALL ON TABLE public.invitation TO anon;
GRANT ALL ON TABLE public.invitation TO authenticated;
GRANT ALL ON TABLE public.invitation TO postgres;
GRANT ALL ON TABLE public.invitation TO service_role;
GRANT ALL ON TABLE public.invitation TO supabase_admin;
COMMENT ON TABLE public.invitation IS 'Stores school sent invitation(s) to outsiders';
CREATE TABLE IF NOT EXISTS public.weld (
  id uuid NOT NULL DEFAULT uuid_generate_v4(),
  created_at timestamp with time zone NOT NULL DEFAULT (now() AT TIME ZONE 'utc'::text),
  updated_at timestamp with time zone NOT NULL DEFAULT (now() AT TIME ZONE 'utc'::text),
  role_id uuid,
  owner_id uuid,
  receiver_id uuid,
  CONSTRAINT cpk_weld PRIMARY KEY (id),
  CONSTRAINT cuq_weld UNIQUE (owner_id, receiver_id),
  CONSTRAINT fk_weld_owner FOREIGN KEY (owner_id) REFERENCES public.school (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
  CONSTRAINT fk_weld_receiver FOREIGN KEY (receiver_id) REFERENCES auth.users (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
  CONSTRAINT fk_weld_role FOREIGN KEY (role_id) REFERENCES public.roles (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION
) TABLESPACE pg_default;
ALTER TABLE IF EXISTS public.weld OWNER to supabase_admin;
ALTER TABLE IF EXISTS public.weld ENABLE ROW LEVEL SECURITY;
GRANT ALL ON TABLE public.weld TO anon;
GRANT ALL ON TABLE public.weld TO authenticated;
GRANT ALL ON TABLE public.weld TO postgres;
GRANT ALL ON TABLE public.weld TO service_role;
GRANT ALL ON TABLE public.weld TO supabase_admin;
COMMENT ON TABLE public.weld IS 'Stores outsider sent join request(s) to various schools';
CREATE OR REPLACE VIEW public.user_with_role AS
SELECT users.instance_id,
  users.id,
  users.aud,
  users.role,
  users.email,
  users.encrypted_password,
  users.email_confirmed_at,
  users.invited_at,
  users.confirmation_token,
  users.confirmation_sent_at,
  users.recovery_token,
  users.recovery_sent_at,
  users.email_change_token_new,
  users.email_change,
  users.email_change_sent_at,
  users.last_sign_in_at,
  users.raw_app_meta_data,
  users.raw_user_meta_data,
  users.is_super_admin,
  users.created_at,
  users.updated_at,
  users.phone,
  users.phone_confirmed_at,
  users.phone_change,
  users.phone_change_token,
  users.phone_change_sent_at,
  users.confirmed_at,
  users.email_change_token_current,
  users.email_change_confirm_status,
  users.banned_until,
  users.role_id,
  roles.permissions,
  roles.name AS app_role
FROM auth.users
  JOIN roles ON users.role_id = roles.id;
ALTER TABLE public.user_with_role OWNER TO supabase_admin;
GRANT ALL ON TABLE public.user_with_role TO anon;
GRANT ALL ON TABLE public.user_with_role TO postgres;
GRANT ALL ON TABLE public.user_with_role TO supabase_admin;
GRANT ALL ON TABLE public.user_with_role TO authenticated;
GRANT ALL ON TABLE public.user_with_role TO service_role;